package LexAnalyser;

import java.io.File;
import java.nio.file.Path;
import java.util.ArrayList;
import java.io.IOException;
import java.nio.file.Files;
import java.io.FileOutputStream;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.stream.Stream;

public class LexAnalyser {
    /**List of tokens with semantic meaning*/
    private static ArrayList<Token> semanticTokens = new ArrayList<>();
    /**Iterator to get next semantic token*/
    public static final Iterator<Token> semanticTokenIterator = new Iterator<>() {
        private int semanticIndex = 0;
        @Override
        public boolean hasNext() {
            return semanticIndex <= semanticTokens.size() - 1;
        }

        @Override
        public Token next() {
            if(hasNext()){
                return semanticTokens.get(semanticIndex++);
            }
            else{
                return new Token("error","error",0);
            }
        }
    };
    /**ArrayList containing a list of all the tokens generated by the lexer*/
    private static ArrayList<Token> outputTokens = new ArrayList<Token>();
    /**Iterator to get next output token*/
    public static final Iterator<Token> outputTokenIterator = new Iterator<>() {
        private int outputTokenIndex = 0;
        @Override
        public boolean hasNext() {
            return outputTokenIndex <= outputTokens.size() - 1;
        }

        @Override
        public Token next() {
            return outputTokens.get(outputTokenIndex++);
        }
    };
    /**File path of original src file*/
    private final String filePath;
    /**String that will be filled up as file is read*/
    private String fileContent;
    /**Total number of lines in the file being read*/
    private int totalNumberOfLines;
    /**Current index of the character the fileContent string*/
    private int index;
    /**Current line number of the character being analysed*/
    private int currentLocation = 1;
    /**Constructor for initialising src code path*/
    public LexAnalyser(String filePath){
        this.filePath = filePath;
    }
    /**Read from file -> Initializes fileContent string as well as totalNumberOfLines*/
    public void readFromFile(){
        StringBuilder sb = new StringBuilder();
        try (Stream<String> stream = Files.lines(Path.of(filePath))) {
            stream.forEach(
                    s -> sb.append(s).append("\n")
            );

        } catch (IOException ex) {
            // Handle exception
        }
        fileContent = sb.toString() + "\n";
        //Finding the number of lines of the file
        //Removing all \r from the fileContent
        fileContent = fileContent.replaceAll("\\r","");
        int numberOfLines = 0;
        for(int i = 0; i < fileContent.length(); i ++){
            if(fileContent.charAt(i) == '\n'){
                numberOfLines++;
            }
        }
        this.totalNumberOfLines = numberOfLines;
    }
    /**Output to outtoken as well as outlexerrors file
     * The paths of both files should be passed as arguments*/
    public void outputToFile(String tokenFilePath,String errorFilePath){
        FileOutputStream tokenStream = null;
        FileOutputStream errorStream = null;
        try{
            File tokenFile = new File(tokenFilePath);
            File errorFile = new File(errorFilePath);
            tokenStream = new FileOutputStream(tokenFile);
            errorStream = new FileOutputStream(errorFile);
            if(!tokenFile.exists()){
                boolean yes = tokenFile.createNewFile();
            }
            if(!errorFile.exists()){
                boolean yes = errorFile.createNewFile();
            }
            int checkLine = 1;
            for(int i = 0;i < totalNumberOfLines - 1; i++){
                while(checkLine == currentLocation){
                    Token t = nextToken();
                    String errorText = "";
                    switch (t.getType()) {
                        case "invalidchar" -> errorText = "Lexical error: Invalid character: \"" + t.getLexeme() + "\": line " + t.getLocation() + '\n';
                        case "invalidid" -> errorText = "Lexical error: Invalid ID: \"" + t.getLexeme() + "\": line " + t.getLocation() +'\n';
                        case "invalidblock" -> errorText =  "Lexical error: Invalid BLOCK COMMENT: \"" + t.getLexeme() + "\": line " + t.getLocation() +'\n';
                    }
                    if(!t.getLexeme().equals("")){
                        tokenStream.write(t.toString().getBytes());
                        if(!t.isInvalid()){
                            outputTokens.add(t);
                            if(t.hasSemanticMeaning()){
                                semanticTokens.add(t);
                            }
                        }
                    }
                    if(!errorText.equals("")){
                        errorStream.write(errorText.getBytes());
                        errorStream.write("\n".getBytes());
                    }
                }
                tokenStream.write("\n".getBytes());
                checkLine++;
            }
            //EOF token
            outputTokens.add(new Token("EOF", "EOF", currentLocation));
        }
        catch(IOException e){
            e.printStackTrace();;
        }
        finally {
            System.out.println("Lex Analysis done!");
            try{
                if(tokenStream!=null){
                    tokenStream.close();
                }
                if(errorStream!=null){
                    errorStream.close();
                }
            }
            catch(IOException e){
                e.printStackTrace();;
            }
        }
    }
    /**Gets the next char of fileContent at index and  increments index*/
    private char nextChar(){
        if(index>= 0 && index < fileContent.length()){
            return fileContent.charAt(index++);
        }
        return ' ';
    }
    /**Gets the previous char of fileContent at index and decrements index*/
    private void backTrackChar() {
        if (index > 0) {
            index--;
        }
    }
    /**Gets the next char of fileContent at index without incrementing index*/
    private char peekNextChar() {
        if(index>= 0 && index < fileContent.length()){
            return fileContent.charAt(index);
        }
        return ' ';
    }
    /**Gets the char of fileContent at index : index + i*/
    private char peekChar(int i){
        if(i>= 0 && i < fileContent.length()){
            return fileContent.charAt(i-1);
        }
        return ' ';
    }
    /**Returns true if character is a digit*/
    private boolean isDigit(char c) {
        char[] digits = {'0','1','2','3','4','5','6','7','8','9'};
        for(char digit : digits){
            if(digit == c)return true;
        }
        return false;
    }
    /**Returns true if character is a letter*/
    private boolean isLetter(char c) {
        char[] letters = {'a','b','c','d','e','f','g','h','i',
                'j','k','l','m','n','o','p','q','r',
                's','t','u','v','w','x','y','z',
                'A','B','C','D','E','F','G','H','I',
                'J','K','L','M','N','O','P','Q','R',
                'S','T','U','V','W','X','Y','Z'};
        for(char letter : letters){
            if(letter == c)return true;
        }
        return false;
    }
    /**Returns true if character is not zero*/
    private boolean isNonZero(char c) {
        return c != '0';
    }
    /**Returns true if character is an alphanum*/
    private boolean isAlphanum(char c){
        return isDigit(c) || isLetter(c) || c == '_';
    }
    /**Returns an id token using all alphanums after firstChar*/
    private Token formIDWithRest(char firstChar){
        StringBuilder id = new StringBuilder(String.valueOf(firstChar));
        char next = nextChar();
        while(isAlphanum(next)){
            id.append(next);
            next = nextChar();
        }
        backTrackChar();
        return new Token("id", id.toString(),currentLocation,true);
    }
    /**MAIN METHOD OF THE LEX ANALYSER -> GENERATES NEXT TOKEN BY INCREASING INDEX OF FILECONTENT STRING AND PASSING THROUGH A LIST OF SWITCH CASES**/
    private Token nextToken(){
        char c = nextChar();
        switch(c){
            case '\t':
            case '\r':
            case '\f':
            case ' ':
                return new Token("", "", currentLocation);
            case '=':
                if(peekNextChar() == '=') {
                    index++;
                    return new Token("eq","==",currentLocation,true);
                }
                else return new Token("equal","=",currentLocation,true);
            case '_':
                if(isAlphanum(peekNextChar())) return formIDWithRest('_');
                else{
                    return new Token("invalidid", String.valueOf(c), currentLocation);
                }
            case '<':
                if(peekNextChar() == '>'){
                    index++;
                    return new Token("neq","<>",currentLocation,true);
                }
                else if(peekNextChar() == '='){
                    index++;
                    return new Token("leq","<=",currentLocation,true);
                }
                else return new Token("lt","<",currentLocation,true);
            case '>':
                if(peekNextChar() == '='){
                    index++;
                    return new Token("geq",">=",currentLocation,true);
                }
                else return new Token("gt",">",currentLocation,true);
            case '+': return new Token("plus", "+", currentLocation,true);
            case '-':
                if(peekNextChar() == '>'){
                    index++;
                    return new Token("arrow","->",currentLocation);
                }
                else return new Token("minus","-",currentLocation,true);
            case '*': return new Token("mult","*",currentLocation,true);
            case '/':
                //IF BLOCK COMMENT
                if(peekNextChar() == '*'){
                    nextChar();
                    StringBuilder comment  = new StringBuilder("/*");int initialLine = currentLocation;
                    int n = 1;
                    while(currentLocation < totalNumberOfLines) {
                        char next = nextChar();
                        if(next == '/' && peekNextChar() == '*'){
                            comment.append(next);
                            comment.append(nextChar());
                            n++;
                        }
                        else if(next == '*' && peekNextChar() == '/'){
                            comment.append(next);
                            comment.append(nextChar());
                            n--;
                        }
                        else if(next == '\n'){
                            comment.append("\\n");
                            currentLocation++;
                        }
                        else comment.append(next);
                        if(n == 0) return new Token("blockcmt", comment.toString(), initialLine);
                    }
                    return new Token("invalidblock", comment.toString(), initialLine);
                }
                //ELSE IF INLINE COMMENT
                else if(peekNextChar() == '/'){
                    StringBuilder comment  = new StringBuilder("//");
                    nextChar();
                    char next = nextChar();
                    while(next != '\r' && next!='\n'){
                        comment.append(next);
                        next = nextChar();
                    }
                    currentLocation++;
                    return new Token("inlinecmt",comment.toString(),currentLocation-1);
                }
                //ELSE IF DIVISION OPERATOR
                else return new Token("div","/",currentLocation,true);
            case '|': return new Token("or","|",currentLocation,true);
            case '&': return new Token("and","&",currentLocation,true);
            case '!': return new Token("not","!",currentLocation,true);
            case '(':return new Token("lpar","(",currentLocation);
            case ')':return new Token("rpar",")",currentLocation);
            case '{':return new Token("lcurbr","{",currentLocation);
            case '}':return new Token("rcurbr","}",currentLocation);
            case '[':return new Token("lsqbr","[",currentLocation);
            case ']':return new Token("rsqbr","]",currentLocation);
            case ';':return new Token("semi",";",currentLocation);
            case ',':return new Token("comma",",",currentLocation);
            case '.':return new Token("dot",".",currentLocation);
            case ':':
                if(peekNextChar() == ':'){
                    nextChar();return new Token("coloncolon","::",currentLocation);
                }
                else return new Token("colon",":",currentLocation);
            case 'i':
                if(peekNextChar() == 'f' && !isAlphanum(peekChar(index + 2))) {
                    index++;return new Token("if","if",currentLocation);
                }
                else if(peekNextChar() == 'n' && peekChar(index+2) == 't' && peekChar(index+3) == 'e' &&
                        peekChar(index+4) == 'g' && peekChar(index+5) == 'e' && peekChar(index+6) == 'r' && !isAlphanum(peekChar(index+7))){
                    index = index + 6;return new Token("integer","integer",currentLocation, true);
                }
                else if(peekNextChar() == 'n' && peekChar(index+2) == 'h' && peekChar(index+3) == 'e' &&
                        peekChar(index+4) == 'r' && peekChar(index+5) == 'i' && peekChar(index+6) == 't' && peekChar(index+7) == 's' && !isAlphanum(peekChar(index+8))){
                    index = index + 7; return new Token("inherits","inherits",currentLocation);
                }
                else if(peekNextChar() == 'm' && peekChar(index+2) == 'p' && peekChar(index+3) == 'l' && !isAlphanum(peekChar(index+4))){
                    index = index+3;return new Token("impl","impl", currentLocation);
                }
                else return formIDWithRest('i');
            case 't':
                if(peekNextChar() == 'h' && peekChar(index+2) == 'e' && peekChar(index+3) == 'n' && !isAlphanum(peekChar(index+4))){
                    index = index + 3;return new Token("then","then",currentLocation);
                }
                else return formIDWithRest('t');
            case 'e':
                if(peekNextChar() == 'l' && peekChar(index+2) == 's' && peekChar(index+3) == 'e' && !isAlphanum(peekChar(index+4))){
                    index = index + 3;return new Token("else","else",currentLocation);
                }
                else return formIDWithRest('e');
            case 'f':
                if(peekNextChar() == 'l' && peekChar(index+2) == 'o' && peekChar(index+3) == 'a' && peekChar(index+4) == 't' && !isAlphanum(peekChar(index+5))){
                    index = index+4;return new Token("float", "float",currentLocation,true);
                }
                else if(peekNextChar() == 'u' && peekChar(index+2) == 'n' && peekChar(index+3) == 'c' && !isAlphanum(peekChar(index+4))){
                    index = index+3;return new Token("func","func",currentLocation);
                }
                else return formIDWithRest('f');
            case 'v':
                if(peekNextChar() == 'o' && peekChar(index+2) == 'i' && peekChar(index+3) == 'd' && !isAlphanum(peekChar(index+4))){
                    index = index + 3; return new Token("void","void",currentLocation,true);
                }
                else if(peekNextChar() == 'a' && peekChar(index+2) == 'r' && !isAlphanum(peekChar(index+3))){
                    index = index+2;return new Token("var","var",currentLocation);
                }
                else return formIDWithRest('v');
            case 'p':
                if(peekNextChar() == 'u' && peekChar(index+2) == 'b' && peekChar(index+3) == 'l' && peekChar(index+4) == 'i' && peekChar(index+5) == 'c'
                        && !isAlphanum(peekChar(index+6))){
                    index = index+5;return new Token("public","public",currentLocation, true);
                }
                else if(peekNextChar() == 'r' && peekChar(index+2) == 'i' && peekChar(index+3) == 'v' && peekChar(index+4) == 'a' && peekChar(index+5) == 't'
                        && peekChar(index+6) == 'e' && !isAlphanum(peekChar(index+7))){
                    index = index + 6; return new Token("private","private",currentLocation, true);
                }
                else return formIDWithRest('p');
            case 's':
                if (peekNextChar() == 't' && peekChar(index + 2) == 'r' && peekChar(index + 3) == 'u' &&
                        peekChar(index + 4) == 'c' && peekChar(index + 5) == 't'
                        && !isAlphanum(peekChar(index + 6))) {
                    index = index + 5;
                    return new Token("struct", "struct", currentLocation);
                }
                else if (peekNextChar() == 'e' && peekChar(index + 2) == 'l' && peekChar(index + 3) == 'f' &&
                        !isAlphanum(peekChar(index + 4))) {
                    index = index + 3;
                    return new Token("self", "self", currentLocation);
                }
                else return formIDWithRest('s');
            case 'w':
                if (peekNextChar() == 'h' && peekChar(index + 2) == 'i' && peekChar(index + 3) == 'l' &&
                        peekChar(index + 4) == 'e' && !isAlphanum(peekChar(index + 5))) {
                    index = index + 4;
                    return new Token("while", "while", currentLocation);
                }
                else if(peekNextChar() == 'r' && peekChar(index + 2) == 'i' && peekChar(index + 3) == 't' &&
                        peekChar(index + 4) == 'e' && !isAlphanum(peekChar(index + 5))) {
                    index = index + 4;
                    return new Token("write", "write", currentLocation);
                }
                else return formIDWithRest('w');
            case 'r':
                if (peekNextChar() == 'e' && peekChar(index + 2) == 'a' && peekChar(index + 3) == 'd' &&
                        !isAlphanum(peekChar(index + 4))) {
                    index = index + 3;
                    return new Token("read", "read", currentLocation);
                }
                else if(peekNextChar() == 'e' && peekChar(index + 2) == 't' && peekChar(index + 3) == 'u' &&
                        peekChar(index + 4) == 'r' && peekChar(index + 5) == 'n' && !isAlphanum(peekChar(index + 6))) {
                    index = index + 5; return new Token("return","return",currentLocation);
                }
                else return formIDWithRest('r');
            case 'l':
                if (peekNextChar() == 'e' && peekChar(index + 2) == 't' && !isAlphanum(peekChar(index + 3))) {
                    index = index + 2; return new Token("let","let",currentLocation);
                }
                else return formIDWithRest('l');
            case '\n':
                currentLocation++;
                return new Token("","", currentLocation);
            //IF C IS A DIGIT
            case '0': case '1': case '2': case '3': case '4' :case'5' :case '6': case '7': case '8' : case '9':
                if(c == '0' && peekNextChar()!= '.') {
                    return new Token("intlit","0",currentLocation,true);
                }
                else{
                    StringBuilder number = new StringBuilder();
                    backTrackChar();
                    char next = nextChar();
                    while(isDigit(next)){
                        number.append(next);
                        next = nextChar();
                    }
                    if(next == '.'){
                        //float
                        number.append(next);
                        next = nextChar();
                        if(next == '0' && !isDigit(peekNextChar())) {
                            number.append(next);
                            return new Token("floatlit",number.toString(),currentLocation,true);
                        }
                        else if(isDigit(next)){
                            number.append(next);
                            next = nextChar();
                            while(isDigit(next)){
                                if(next == '0' && !isDigit(peekNextChar())){
                                    backTrackChar();return new Token("floatlit",number.toString(),currentLocation,true);
                                }
                                number.append(next);
                                next = nextChar();
                            }
                            if(next == 'e'){
                                if(peekNextChar() == '+' || peekNextChar() == '-'){
                                    if(isNonZero(peekChar(index+2))){
                                        number.append(next);
                                        next = nextChar();
                                        number.append(next);
                                        next = nextChar();
                                        while(isDigit(next)){
                                            number.append(next);
                                            next = nextChar();
                                        }
                                        backTrackChar(); return new Token("floatlit",number.toString(),currentLocation,true);
                                    }
                                    else{
                                        backTrackChar(); return new Token("floatlit",number.toString(),currentLocation,true);
                                    }
                                }
                                else if(isNonZero(peekNextChar())){
                                    number.append(next);
                                    next = nextChar();
                                    while(isDigit(next)){
                                        number.append(next);
                                        next = nextChar();
                                    }
                                    backTrackChar();
                                    return new Token("floatlit",number.toString(),currentLocation,true);
                                }
                                else{
                                    backTrackChar();return new Token("floatlit",number.toString(),currentLocation,true);
                                }
                            }
                            else{
                                backTrackChar();return new Token("floatlit",number.toString(),currentLocation,true);
                            }
                        }
                        else{
                            //not float, just a . after int
                            number.deleteCharAt(number.length() -1);
                            backTrackChar();
                            return new Token("intlit",number.toString(),currentLocation,true);
                        }
                    }
                    else{
                        backTrackChar();
                        return new Token("intlit",number.toString(),currentLocation, true);
                    }
                }
            default: break;
        }
        if(isLetter(c)){
            return formIDWithRest(c);
        }
        else return new Token("invalidchar",String.valueOf(c) ,currentLocation);
    }
}
